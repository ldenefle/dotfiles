#!/usr/bin/python
import datetime
import bisect
import argparse
import signal
import subprocess
import time

def parse_timestamp(raw_str):
    tokens = raw_str.split()

    if len(tokens) == 1:
        if tokens[0].lower() == "never":
            return "never"
        raise Exception("Parse error in timestamp")

    if len(tokens) == 3:
        return datetime.datetime.strptime(" ".join(tokens[1:]), "%Y/%m/%d %H:%M:%S")

    raise Exception("Parse error in timestamp")


def timestamp_is_ge(t1, t2):
    if t1 == "never":
        return True

    if t2 == "never":
        return False

    return t1 >= t2


def timestamp_is_lt(t1, t2):
    if t1 == "never":
        return False

    if t2 == "never":
        return t1 != "never"

    return t1 < t2


def timestamp_is_between(t, tstart, tend):
    return timestamp_is_ge(t, tstart) and timestamp_is_lt(t, tend)


def parse_hardware(raw_str):
    tokens = raw_str.split()

    if len(tokens) == 2:
        return tokens[1]

    else:
        raise Exception("Parse error in hardware")


def strip_endquotes(raw_str):
    return raw_str.strip('"')


def identity(raw_str):
    return raw_str


def parse_binding_state(raw_str):
    tokens = raw_str.split()

    if len(tokens) == 2:
        return tokens[1]

    else:
        raise Exception("Parse error in binding state")


def parse_next_binding_state(raw_str):
    tokens = raw_str.split()

    if len(tokens) == 3:
        return tokens[2]

    else:
        raise Exception("Parse error in next binding state")


def parse_rewind_binding_state(raw_str):
    tokens = raw_str.split()

    if len(tokens) == 3:
        return tokens[2]

    else:
        raise Exception("Parse error in next binding state")


def parse_leases_file(leases_file):
    valid_keys = {
        "starts": parse_timestamp,
        "ends": parse_timestamp,
        "tstp": parse_timestamp,
        "tsfp": parse_timestamp,
        "atsfp": parse_timestamp,
        "cltt": parse_timestamp,
        "hardware": parse_hardware,
        "binding": parse_binding_state,
        "next": parse_next_binding_state,
        "rewind": parse_rewind_binding_state,
        "uid": strip_endquotes,
        "client-hostname": strip_endquotes,
        "option": identity,
        "set": identity,
        "on": identity,
        "abandoned": None,
        "bootp": None,
        "reserved": None,
    }

    leases_db = {}

    lease_rec = {}
    in_lease = False
    in_failover = False

    for line in leases_file:
        if line.lstrip().startswith("#"):
            continue

        tokens = line.split()

        if len(tokens) == 0:
            continue

        key = tokens[0].lower()

        if key == "lease":
            if not in_lease:
                ip_address = tokens[1]

                lease_rec = {"ip_address": ip_address}
                in_lease = True

            else:
                raise Exception("Parse error in leases file")

        elif key == "failover":
            in_failover = True
        elif key == "}":
            if in_lease:
                for k in valid_keys:
                    if callable(valid_keys[k]):
                        lease_rec[k] = lease_rec.get(k, "")
                    else:
                        lease_rec[k] = False

                ip_address = lease_rec["ip_address"]

                if ip_address in leases_db:
                    leases_db[ip_address].insert(0, lease_rec)

                else:
                    leases_db[ip_address] = [lease_rec]

                lease_rec = {}
                in_lease = False

            elif in_failover:
                in_failover = False
                continue
            else:
                raise Exception("Parse error in leases file")

        elif key in valid_keys:
            if in_lease:
                value = line[(line.index(key) + len(key)) :]
                value = value.strip().rstrip(";").rstrip()

                if callable(valid_keys[key]):
                    lease_rec[key] = valid_keys[key](value)
                else:
                    lease_rec[key] = True

            else:
                raise Exception("Parse error in leases file")

        else:
            if in_lease:
                raise Exception("Parse error in leases file")

    if in_lease:
        raise Exception("Parse error in leases file")

    return leases_db


def round_timedelta(tdelta):
    return datetime.timedelta(
        tdelta.days, tdelta.seconds + (0 if tdelta.microseconds < 500000 else 1)
    )


def timestamp_now():
    n = datetime.datetime.now(datetime.UTC)
    return datetime.datetime(
        n.year,
        n.month,
        n.day,
        n.hour,
        n.minute,
        n.second
    )


def lease_is_active(lease_rec, as_of_ts):
    return timestamp_is_between(as_of_ts, lease_rec["starts"], lease_rec["ends"])


def ipv4_to_int(ipv4_addr):
    parts = ipv4_addr.split(".")
    return (
        (int(parts[0]) << 24)
        + (int(parts[1]) << 16)
        + (int(parts[2]) << 8)
        + int(parts[3])
    )


def select_active_leases(leases_db, as_of_ts):
    retarray = []
    sortedarray = []

    for ip_address in leases_db:
        lease_rec = leases_db[ip_address][0]

        if lease_is_active(lease_rec, as_of_ts):
            ip_as_int = ipv4_to_int(ip_address)
            insertpos = bisect.bisect(sortedarray, ip_as_int)
            sortedarray.insert(insertpos, ip_as_int)
            retarray.insert(insertpos, lease_rec)

    return retarray


##############################################################################


def get_leases(now):
    with open("/var/lib/dhcp/dhcpd.leases", "r") as f:
        leases = parse_leases_file(f)
        return select_active_leases(leases, now)


def dump_leases(leases, now):
    print(
        "+------------------------------------------------------------------------------"
    )
    print("| DHCPD ACTIVE LEASES REPORT")
    print(
        "+-----------------+-------------------+----------------------+-----------------"
    )
    print(
        "| IP Address      | MAC Address       | Expires (days,H:M:S) | Client Hostname "
    )
    print(
        "+-----------------+-------------------+----------------------+-----------------"
    )

    for lease in leases:
        print(
            "| "
            + format(lease["ip_address"], "<15")
            + " | "
            + format(lease["hardware"], "<17")
            + " | "
            + format(
                str((lease["ends"] - now) if lease["ends"] != "never" else "never"),
                ">20",
            )
            + " | "
            + lease["client-hostname"]
        )

    print(
        "+-----------------+-------------------+----------------------+-----------------"
    )
    print("| Total Active Leases: " + str(len(leases)))
    print("| Report generated (UTC): " + str(now))
    print(
        "+------------------------------------------------------------------------------"
    )


def notify_leases(leases, now):
    for lease in leases:
        hostname = lease["client-hostname"]
        ip_address = lease["ip_address"]
        expiry = str((lease["ends"] - now) if lease["ends"] != "never" else "never")
        subprocess.run(["notify-send", "-u", "normal", "-t", "5000",
                        "DHCP lease", f"{hostname} connected at {ip_address} expires at {expiry}"], check=True)


class GracefulKiller:
    kill_now = False

    def __init__(self):
        signal.signal(signal.SIGINT, self.exit_gracefully)
        signal.signal(signal.SIGTERM, self.exit_gracefully)

    def exit_gracefully(self, signum, frame):
        self.kill_now = True


def main():
    parser = argparse.ArgumentParser(
        prog="dhcp-list-leases",
        description="Crawl the dhcpd db to list leases, dump them and optionally send notifs",
        epilog="Text at the bottom of help",
    )

    parser.add_argument(
        "--daemon",
        default=False,
        action="store_true",
        help="Uses as daemon mode, will trigger notify-send when lease db changes",
    )  # on/off flag

    args = parser.parse_args()

    if args.daemon:
        killer = GracefulKiller()
        report_dataset = list()
        while not killer.kill_now:
            now = timestamp_now()
            current_dataset = get_leases(now)
            if report_dataset != current_dataset:
                notify_leases(current_dataset, now)
                report_dataset = current_dataset
            time.sleep(1)
    else:
        now = timestamp_now()
        report_dataset = get_leases(now)
        dump_leases(report_dataset, now)

if __name__ == "__main__":
    main()
